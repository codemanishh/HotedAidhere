import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { Job, JobFormData, ExperienceLevel } from "@/types/job";
import { useToast } from "@/hooks/use-toast";

export const useAdminJobs = () => {
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const jobsQuery = useQuery({
    queryKey: ["adminJobs"],
    queryFn: async (): Promise<Job[]> => {
      const { data, error } = await supabase
        .from("jobs")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      
      return (data || []).map(job => ({
        ...job,
        experience: job.experience as ExperienceLevel
      }));
    },
  });

  const createJobMutation = useMutation({
    mutationFn: async (jobData: JobFormData) => {
      const { data, error } = await supabase
        .from("jobs")
        .insert([{
          ...jobData,
          slug: '', // Will be generated by trigger
        }])
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["adminJobs"] });
      queryClient.invalidateQueries({ queryKey: ["jobs"] });
      toast({
        title: "Job Posted!",
        description: "Your job has been successfully posted.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message || "Failed to create job",
        variant: "destructive",
      });
    },
  });

  const updateJobMutation = useMutation({
    mutationFn: async ({ jobId, jobData }: { jobId: string; jobData: Partial<JobFormData & { is_active: boolean }> }) => {
      const { data, error } = await supabase
        .from("jobs")
        .update(jobData)
        .eq("id", jobId)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["adminJobs"] });
      queryClient.invalidateQueries({ queryKey: ["jobs"] });
      toast({
        title: "Job Updated!",
        description: "The job has been successfully updated.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message || "Failed to update job",
        variant: "destructive",
      });
    },
  });

  const toggleJobStatusMutation = useMutation({
    mutationFn: async ({ jobId, isActive }: { jobId: string; isActive: boolean }) => {
      const { data, error } = await supabase
        .from("jobs")
        .update({ is_active: isActive })
        .eq("id", jobId)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ["adminJobs"] });
      queryClient.invalidateQueries({ queryKey: ["jobs"] });
      toast({
        title: variables.isActive ? "Job Activated" : "Job Deactivated",
        description: variables.isActive 
          ? "The job is now visible to users." 
          : "The job is now hidden from users.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message || "Failed to update job status",
        variant: "destructive",
      });
    },
  });

  const deleteJobMutation = useMutation({
    mutationFn: async (jobId: string) => {
      const { error } = await supabase
        .from("jobs")
        .delete()
        .eq("id", jobId);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["adminJobs"] });
      queryClient.invalidateQueries({ queryKey: ["jobs"] });
      toast({
        title: "Job Deleted",
        description: "The job has been successfully deleted.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message || "Failed to delete job",
        variant: "destructive",
      });
    },
  });

  const stats = {
    activeJobs: jobsQuery.data?.filter(j => j.is_active && new Date(j.expires_at) > new Date()).length || 0,
    expiredJobs: jobsQuery.data?.filter(j => !j.is_active || new Date(j.expires_at) <= new Date()).length || 0,
    totalJobs: jobsQuery.data?.length || 0,
  };

  return {
    jobs: jobsQuery.data || [],
    isLoading: jobsQuery.isLoading,
    error: jobsQuery.error,
    stats,
    createJob: createJobMutation.mutate,
    isCreating: createJobMutation.isPending,
    updateJob: updateJobMutation.mutate,
    isUpdating: updateJobMutation.isPending,
    toggleJobStatus: toggleJobStatusMutation.mutate,
    isTogglingStatus: toggleJobStatusMutation.isPending,
    deleteJob: deleteJobMutation.mutate,
    isDeleting: deleteJobMutation.isPending,
  };
};
